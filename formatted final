#include <TinyGPS++.h>
#include <WiFi.h>
#include <Preferences.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include "painlessMesh.h"
#include <ArduinoJson.h>
#include <HardwareSerial.h>

// OLED display size definition
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 32

// Page switching variables for display
int currentPage = 0;
unsigned long lastPageSwitch = 0;
const int pageSwitchInterval = 3000; // 3 seconds between page switches

// GPS serial port pins
#define RXD2 16
#define TXD2 17
#define GPS_BAUD 9600

// Mesh configuration
#define MAX_ESPS 3  // Max number of ESP nodes we track

// SOS button configuration
#define SOS_BUTTON_PIN 4
#define MAX_SOS_ALERTS 10  // Max number of SOS alerts to store
#define MAX_SOS_SENT 3     // Limit per device
#define SOS_COOLDOWN 5000  // Delay between SOS sends in milliseconds

// Listener button pin
#define LISTENER_BUTTON_PIN 5
#define RXD3 18
#define TXD3 19

// Mesh network configuration
#define MESH_PREFIX "whateverYouLike"
#define MESH_PASSWORD "somethingSneaky"
#define MESH_PORT 5555

// OLED display instance
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);

// GPS and preferences setup
TinyGPSPlus gps;
Preferences preferences;
String deviceName;

// Serial interfaces
HardwareSerial gpsSerial(2);
HardwareSerial HC12(1);

// Mesh and scheduler
Scheduler userScheduler;
painlessMesh mesh;

// Data structures
struct GPSData {
    float latitude;
    float longitude;
    float speed_kmh;
    float altitude_m;
    float hdop;
    int satellites;
    long timestamp;
};

struct TransmittedData {
    char name[10];
    GPSData gpsData;
    bool isSOS;
};

struct ESPNodeData {
    char name[10];
    GPSData gpsData;
    unsigned long lastUpdateTime;
};

struct SOSAlert {
    String name;
    long timestamp;
};

// SOS state and storage
SOSAlert sosAlerts[MAX_SOS_ALERTS];
int sosAlertCount = 0;
int alertsSent = 0;
bool sosActive;
unsigned long lastSOSSendTime = 0;
SOSAlert currentSOS;
long sosStartTime = millis();

// Node tracking
ESPNodeData espNodes[MAX_ESPS];
int espNodeCount = 0;

// Data variables
GPSData gpsDataToSend;
GPSData receivedGPSData;

// Creates a JSON message from TransmittedData
String createJsonMessage(const TransmittedData& data) {
    StaticJsonDocument<256> doc;
    doc["name"] = data.name;
    doc["latitude"] = data.gpsData.latitude;
    doc["longitude"] = data.gpsData.longitude;
    doc["timestamp"] = data.gpsData.timestamp;
    doc["isSOS"] = data.isSOS;

    String jsonString;
    serializeJson(doc, jsonString);
    return jsonString;
}

// Parses incoming JSON messages into TransmittedData structures
bool deserialiseJsonMessage(const String &msg, TransmittedData &data) {
    StaticJsonDocument<256> doc;
    DeserializationError error = deserializeJson(doc, msg);
    if (error) {
        Serial.print("deserializeJson() failed: ");
        Serial.println(error.c_str());
        return false;
    }

    memset(&data, 0, sizeof(data));

    strlcpy(data.name, doc["name"] | "", sizeof(data.name));
    data.gpsData.latitude = doc["latitude"] | 0.0;
    data.gpsData.longitude = doc["longitude"] | 0.0;
    data.gpsData.timestamp = doc["timestamp"] | 0;

    // Handle optional SOS field
    data.isSOS = doc.containsKey("isSOS") ? doc["isSOS"] : false;

    return true;
}

// Updates or adds ESP node data based on received data
void updateESPData(const char* espName, GPSData receivedData) {
    for (int i = 0; i < espNodeCount; i++) {
        if (strcmp(espNodes[i].name, espName) == 0) {
            espNodes[i].gpsData = receivedData;
            espNodes[i].lastUpdateTime = receivedData.timestamp;
            return;
        }
    }

    if (espNodeCount < MAX_ESPS) {
        strncpy(espNodes[espNodeCount].name, espName, sizeof(espNodes[espNodeCount].name));
        espNodes[espNodeCount].gpsData = receivedData;
        espNodes[espNodeCount].lastUpdateTime = receivedData.timestamp;
        espNodeCount++;
    } else {
        Serial.println("ESP storage full! - Increase MAX_ESPs.");
    }
}

// Handles incoming mesh messages
void receivedCallback(uint32_t from, String &msg) {
    Serial.printf("Received from %u msg=%s\n", from, msg.c_str());
    TransmittedData receivedData;
    if (deserialiseJsonMessage(msg, receivedData)) {
        updateESPData(receivedData.name, receivedData.gpsData);

        if (receivedData.isSOS) {
            currentSOS.name = String(receivedData.name);
            currentSOS.timestamp = receivedData.gpsData.timestamp;
            sosStartTime = millis();

            if (sosAlertCount < MAX_SOS_ALERTS) {
                sosAlerts[sosAlertCount++] = currentSOS;
            }
            sosActive = true;
        }
        updateESPData(receivedData.name, receivedData.gpsData);
    }
}

// Mesh connection callbacks
void newConnectionCallback(uint32_t nodeId) {
    Serial.printf("New Connection, nodeId = %u\n", nodeId);
}

void changedConnectionCallback() {
    Serial.println("Changed connections");
}

void nodeTimeAdjustedCallback(int32_t offset) {
    Serial.printf("Adjusted time %u. Offset = %d\n", mesh.getNodeTime(), offset);
}

// Sends an SOS broadcast message over the mesh
void sendSOS() {
    if (millis() - lastSOSSendTime < SOS_COOLDOWN) return;

    TransmittedData dataToSend;
    strncpy(dataToSend.name, deviceName.c_str(), sizeof(dataToSend.name));
    dataToSend.gpsData = gpsDataToSend;
    dataToSend.isSOS = true;

    String jsonMessage = createJsonMessage(dataToSend);
    mesh.sendBroadcast(jsonMessage);
    lastSOSSendTime = millis();
    alertsSent++;

    Serial.println("SOS message sent!");
}

// Reads and returns a GPSData structure from the GPS module
GPSData readGPS() {
    GPSData gpsData = {};
    unsigned long start = millis();

    while (millis() - start < 1000) {
        while (gpsSerial.available() > 0) {
            gps.encode(gpsSerial.read());
        }
    }

    if (gps.location.isValid()) {
        gpsData.latitude = gps.location.lat();
        gpsData.longitude = gps.location.lng();
        gpsData.speed_kmh = gps.speed.kmph();
        gpsData.altitude_m = gps.altitude.meters();
        gpsData.hdop = gps.hdop.value() / 100.0;
        gpsData.satellites = gps.satellites.value();

        if (gps.date.isValid() && gps.time.isValid()) {
            struct tm timeinfo;
            timeinfo.tm_year = gps.date.year() - 1900;
            timeinfo.tm_mon = gps.date.month() - 1;
            timeinfo.tm_mday = gps.date.day();
            timeinfo.tm_hour = gps.time.hour() + 1;
            timeinfo.tm_min = gps.time.minute();
            timeinfo.tm_sec = gps.time.second();

            gpsData.timestamp = mktime(&timeinfo);
        }
    }

    return gpsData;
}

// Sends data to a listener via HC12
void sendToListener(const String& type) {
    StaticJsonDocument<2048> doc;
    doc["type"] = type;

    JsonArray arr = doc.createNestedArray("data");

    if (type == "SOS") {
        for (int i = 0; i < sosAlertCount; i++) {
            JsonObject obj = arr.createNestedObject();
            obj["name"] = sosAlerts[i].name;
            obj["timestamp"] = sosAlerts[i].timestamp;
        }
    } else if (type == "ESP") {
        for (int i = 0; i < espNodeCount; i++) {
            JsonObject obj = arr.createNestedObject();
            obj["name"] = espNodes[i].name;

            JsonObject gps = obj.createNestedObject("gps");
            gps["latitude"] = espNodes[i].gpsData.latitude;
            gps["longitude"] = espNodes[i].gpsData.longitude;
            gps["speed_kmh"] = espNodes[i].gpsData.speed_kmh;
            gps["altitude_m"] = espNodes[i].gpsData.altitude_m;
            gps["hdop"] = espNodes[i].gpsData.hdop;
            gps["satellites"] = espNodes[i].gpsData.satellites;
            gps["timestamp"] = espNodes[i].gpsData.timestamp;

            obj["lastUpdateTime"] = espNodes[i].lastUpdateTime;
        }
    }

    String output;
    serializeJson(doc, output);
    HC12.println(output);
}

// Setup function - initialises all hardware
void setup() {
    Serial.begin(115200);

    preferences.begin("ESP_Config", true);
    deviceName = preferences.getString("device_name", "Unknown");
    preferences.end();

    pinMode(LISTENER_BUTTON_PIN, INPUT_PULLUP);
    pinMode(SOS_BUTTON_PIN, INPUT_PULLUP);

    HC12.begin(9600, SERIAL_8N1, TXD3, RXD3);

    if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
        Serial.println(F("SSD1306 allocation failed"));
        while (true);
    }

    mesh.setDebugMsgTypes(ERROR | STARTUP);
    mesh.init(MESH_PREFIX, MESH_PASSWORD, &userScheduler, MESH_PORT);
    mesh.onReceive(&receivedCallback);
    mesh.onNewConnection(&newConnectionCallback);
    mesh.onChangedConnections(&changedConnectionCallback);
    mesh.onNodeTimeAdjusted(&nodeTimeAdjustedCallback);

    gpsSerial.begin(GPS_BAUD, SERIAL_8N1, RXD2, TXD2);
    Serial.println("GPS initialized.");
}

// Main loop
void loop() {
    mesh.update();
    gpsDataToSend = readGPS();

    if (gpsDataToSend.latitude != 0 && gpsDataToSend.longitude != 0) {
        TransmittedData dataToSend;
        strncpy(dataToSend.name, deviceName.c_str(), sizeof(dataToSend.name));
        dataToSend.gpsData = gpsDataToSend;
        dataToSend.isSOS = false;
        String jsonMessage = createJsonMessage(dataToSend);
        mesh.sendBroadcast(jsonMessage);

        Serial.print("Sending data from: ");
        Serial.println(dataToSend.name);
    } else {
        Serial.println("Waiting for valid GPS signal...");
    }

    if (digitalRead(SOS_BUTTON_PIN) == LOW && alertsSent < MAX_SOS_SENT) {
        sendSOS();
        delay(500);
    }

    if (digitalRead(LISTENER_BUTTON_PIN) == LOW) {
        Serial.println("Attempting Listener Upload");
        if (sosAlertCount > 0) sendToListener("SOS");
        if (espNodeCount > 0) sendToListener("ESP");
        delay(500);
    }

    printSOSData();

    if (sosActive) {
        if (millis() - sosStartTime < 5000) {
            displaySOSAlert(currentSOS);
        } else {
            sosActive = false;
            display.clearDisplay();
        }
    } else {
        outputESPData(gpsDataToSend.latitude, gpsDataToSend.longitude, gpsDataToSend.timestamp);
    }

    mesh.update();
}

// Prints ESP node data to serial monitor
void printESPData() {
    Serial.println("Tracked ESP Nodes:");
    for (int i = 0; i < espNodeCount; i++) {
        Serial.print("ESP Name: ");
        Serial.println(espNodes[i].name);
        Serial.print("Latitude: ");
        Serial.println(espNodes[i].gpsData.latitude, 6);
        Serial.print("Longitude: ");
        Serial.println(espNodes[i].gpsData.longitude, 6);
        Serial.print("Last Updated: ");
        time_t timestamp = espNodes[i].lastUpdateTime;
        Serial.println(ctime(&timestamp));
        Serial.println("----------------------");
    }
}

// Prints all stored SOS alerts
void printSOSData() {
    Serial.println("Saved SOS ALERTS:");
    for (int i = 0; i < sosAlertCount; i++) {
        Serial.print("SOS FROM Name: ");
        Serial.println(sosAlerts[i].name);
        Serial.print("Timestamp: ");
        time_t timestamp = sosAlerts[i].timestamp;
        Serial.println(ctime(&timestamp));
        Serial.println("----------------------");
    }
}

// Displays current ESP data on OLED
void outputESPData(float lat, float lon, long timestamp) {
    unsigned long currentMillis = millis();

    if (currentMillis - lastPageSwitch >= pageSwitchInterval) {
        currentPage = (currentPage + 1) % 3;
        lastPageSwitch = currentMillis;
    }

    display.clearDisplay();
    display.setTextSize(1);
    display.setTextColor(WHITE);
    display.setCursor(0, 10);

    if (currentPage == 0) {
        display.print("ESP Name: ");
        display.println(deviceName);
        time_t new_timestamp = timestamp;
        struct tm *timeInfo = localtime(&new_timestamp);
        display.print("Time: ");
        display.printf("%02d:%02d:%02d", timeInfo->tm_hour, timeInfo->tm_min, timeInfo->tm_sec);
    } else {
        display.print("Lat: ");
        display.println(lat, 6);
        display.print("Lon: ");
        display.println(lon, 6);
    }

    display.display();
}

// Displays an SOS alert on the OLED screen
void displaySOSAlert(SOSAlert alert) {
    display.clearDisplay();
    display.setTextSize(1);
    display.setTextColor(WHITE);
    display.setCursor(0, 10);
    display.print("SOS ALERT RECEIVED! - ");
    display.print("From: ");
    display.println(alert.name);
    display.print("Time: ");
    time_t sosTime = alert.timestamp;
    struct tm *timeInfo = localtime(&sosTime);
    display.printf("%02d:%02d:%02d", timeInfo->tm_hour, timeInfo->tm_min, timeInfo->tm_sec);
    display.display();
}
